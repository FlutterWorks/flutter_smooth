"use strict";(self.webpackChunksmooth=self.webpackChunksmooth||[]).push([[8466],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=p(n),u=r,m=h["".concat(l,".").concat(u)]||h[u]||c[u]||o;return n?i.createElement(m,a(a({ref:t},d),{},{components:n})):i.createElement(m,a({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,a=new Array(o);a[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var p=2;p<o;p++)a[p]=n[p];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8765:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var i=n(7462),r=(n(7294),n(3905));const o={},a="Implementation",s={unversionedId:"design/infra/gesture/impl",id:"design/infra/gesture/impl",title:"Implementation",description:'With the "animation" section above, we are already able to show some animations like enter-page transition even when the frame is very janky. However, what if the user interacts with the UI, such as dragging the ListView? Without the implementation in this section, the PointerMoveEvent will not be handled at all during a janky frame, because event handling happens between frames, so the preempt will render identical content in each scene. Thus, the user still feels the UI is freezed during a janky frame, even though it is 60FPS. This section is to solve the problem.',source:"@site/docs/design/infra/gesture/impl.md",sourceDirName:"design/infra/gesture",slug:"/design/infra/gesture/impl",permalink:"/flutter_smooth/design/infra/gesture/impl",draft:!1,editUrl:"https://github.com/fzyzcjy/flutter_smooth/tree/master/website/docs/design/infra/gesture/impl.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Gesture",permalink:"/flutter_smooth/design/infra/gesture/"},next:{title:"Deliberate delay",permalink:"/flutter_smooth/design/infra/gesture/delay"}},l={},p=[{value:"How to get events",id:"how-to-get-events",level:2},{value:"How to dispatch events",id:"how-to-dispatch-events",level:2},{value:"<code>PointerDownEvent</code> and so on",id:"pointerdownevent-and-so-on",level:3},{value:"<code>PointerMoveEvent</code> and so on",id:"pointermoveevent-and-so-on",level:3}],d={toc:p};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,'With the "animation" section above, we are already able to show some animations like enter-page transition even when the frame is very janky. However, what if the user interacts with the UI, such as dragging the ListView? ',(0,r.kt)("em",{parentName:"p"},"Without")," the implementation in this section, the ",(0,r.kt)("inlineCode",{parentName:"p"},"PointerMoveEvent")," will not be handled at all during a janky frame, because event handling happens between frames, so the preempt will render identical content in each scene. Thus, the user still feels the UI is freezed during a janky frame, even though it is 60FPS. This section is to solve the problem."),(0,r.kt)("h2",{id:"how-to-get-events"},"How to get events"),(0,r.kt)("p",null,'Quite simple - just "peek" from the engine. More specifically, whenever Flutter engine receives a (raw) pointer event from OS, it is enqueued to a peek queue. Then, at suitable time such as before preempt, we dequeue them and dispatch them.'),(0,r.kt)("h2",{id:"how-to-dispatch-events"},"How to dispatch events"),(0,r.kt)("p",null,"(Refer to source code of ",(0,r.kt)("inlineCode",{parentName:"p"},"GestureBinding._handlePointerEventImmediately")," for this part.)"),(0,r.kt)("h3",{id:"pointerdownevent-and-so-on"},(0,r.kt)("inlineCode",{parentName:"h3"},"PointerDownEvent")," and so on"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"This only occurs for a small portion of frames. Most frames will have ",(0,r.kt)("inlineCode",{parentName:"p"},"PointerMoveEvent")," or no finger.")),(0,r.kt)("p",null,'Indeed we cannot do that. This is because, for a "down" event, it needs to go through the ',(0,r.kt)("inlineCode",{parentName:"p"},"hitTest")," besides ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatchEvent"),". However, to ",(0,r.kt)("inlineCode",{parentName:"p"},"hitTest")," something in the auxiliary tree, it must pass through ",(0,r.kt)("inlineCode",{parentName:"p"},"RenderObject"),"s in the main tree. As we know, those ",(0,r.kt)("inlineCode",{parentName:"p"},"RenderObject"),"s in the main tree are dirty since we are in the ",(0,r.kt)("em",{parentName:"p"},"middle")," of build and layout phase, so we should not call ",(0,r.kt)("inlineCode",{parentName:"p"},"hitTest")," on them."),(0,r.kt)("p",null,'However, this will not cause jank at all, because the "brake" mechanism discussed before solves the problem.'),(0,r.kt)("h3",{id:"pointermoveevent-and-so-on"},(0,r.kt)("inlineCode",{parentName:"h3"},"PointerMoveEvent")," and so on"),(0,r.kt)("p",null,"By looking at source code, we know it will merely go through a ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatchEvent"),". If a ",(0,r.kt)("inlineCode",{parentName:"p"},"RenderObject")," inside auxiliary tree registers its interest in a pointer, it will ",(0,r.kt)("em",{parentName:"p"},"directly")," get called during dispatch, without the need to touch other ",(0,r.kt)("inlineCode",{parentName:"p"},"RenderObject"),"s - unlike ",(0,r.kt)("inlineCode",{parentName:"p"},"PointerDownEvent"),". That is perfect for our use case. We can simply go through the ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatchEvent")," routine (and make a simple filter so only call those RenderObjects in auxiliary tree), and will not need to interact with dirty main tree RenderObjects."))}c.isMDXComponent=!0}}]);